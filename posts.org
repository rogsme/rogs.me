#+hugo_base_dir: ./
#+hugo_section: ./posts

#+hugo_auto_set_lastmod: t

#+author: Roger Gonzalez

* Programming :programming:
:PROPERTIES:
:ID:       622d1d7a-cef9-4eb6-838c-552086182fec
:END:
All posts in here will have the category set to /programming/.
** Using MinIO to upload to a local S3 bucket in Django :python::django::minio::docker::dockercompose:
:PROPERTIES:
:ID:       b693b4e8-0550-4238-8a64-30866a47768a
:EXPORT_FILE_NAME: using-minio-to-upload-to-a-local-s3-bucket-in-django
:EXPORT_DATE: 2021-01-10
:END:

So MinIO its an object storage that uses the same API as S3, which means that we
can  use the same S3 compatible libraries in Python, like [[https://pypi.org/project/boto3/][Boto3]] and [[https://pypi.org/project/django-storages/][django-storages]].

*** The setup
:PROPERTIES:
:ID:       f2ed5f13-5a27-4da8-a8d2-72500d652ba1
:END:

Here's the docker-compose configuration for my django app:

#+begin_src yaml
version: "3"

services:
  app:
    build:
      context: .
    volumes:
      - ./app:/app
    ports:
      - 8000:8000
    depends_on:
      - minio
    command: >
      sh -c "python manage.py migrate &&
             python manage.py runserver 0.0.0.0:8000"

  minio:
    image: minio/minio
    ports:
      - 9000:9000
    environment:
      - MINIO_ACCESS_KEY=access-key
      - MINIO_SECRET_KEY=secret-key
    command: server /export

  createbuckets:
    image: minio/mc
    depends_on:
      - minio
    entrypoint: >
      /bin/sh -c "
      apk add nc &&
      while ! nc -z minio 9000; do echo 'Wait minio to startup...' && sleep 0.1; done; sleep 5 &&
      /usr/bin/mc config host add myminio http://minio:9000 access-key secret-key;
      /usr/bin/mc mb myminio/my-local-bucket;
      /usr/bin/mc policy download myminio/my-local-bucket;
      exit 0;
      "
#+end_src

- ~app~ is my Django app. Nothing new here.
- ~minio~ is the MinIO instance.
- ~createbuckets~ is a quick instance that creates a new bucket on startup, that
  way we don't need to create the bucket manually.

On my app, in ~settings.py~:

#+begin_src python
# S3 configuration

DEFAULT_FILE_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"

AWS_ACCESS_KEY_ID = os.environ.get("AWS_ACCESS_KEY_ID", "access-key")
AWS_SECRET_ACCESS_KEY = os.environ.get("AWS_SECRET_ACCESS_KEY", "secret-key")
AWS_STORAGE_BUCKET_NAME = os.environ.get("AWS_STORAGE_BUCKET_NAME", "my-local-bucket")

if DEBUG:
    AWS_S3_ENDPOINT_URL = "http://minio:9000"
#+end_src

If we were in a production environment, the ~AWS_ACCESS_KEY_ID~,
~AWS_SECRET_ACCESS_KEY~ and ~AWS_STORAGE_BUCKET_NAME~ would be read from the
environmental variables, but since we haven't set those up and we have
~DEBUG=True~, we are going to use the default ones, which point directly to
MinIO.


And that's it! That's everything you need to have your local S3 development environment. 

*** Testing
:PROPERTIES:
:ID:       61f1cffa-59de-405e-853b-57547a96165b
:END:

First, let's create our model. This is a simple mock model for testing purposes:

#+begin_src python
from django.db import models


class Person(models.Model):
    """This is a demo person model"""

    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    date_of_birth = models.DateField()
    picture = models.ImageField()

    def __str__(self):
        return f"{self.first_name} {self.last_name} {str(self.date_of_birth)}"
#+end_src

Then, in the Django admin we can interact with our new model:

[[/2021-01-10-135111.png]]

[[/2021-01-10-135130.png]]


If we go to the URL and change the domain to ~localhost~, we should be able to
see the picture we uploaded.

[[/2021-01-10-140016.png]]

*** Bonus: The MinIO browser
:PROPERTIES:
:ID:       40acc926-5083-4682-b9be-63cac1c253cb
:END:
MinIO has a local objects browser. If you want to check it out you just need to
go to http://localhost:9000. With my docker-compose configuration, the
credentials are:

#+begin_src bash
username: access-key
password: secret-key
#+end_src

[[/2021-01-10-140236.png]]

On the browser, you can see your uploads, delete them, add new ones, etc.

[[/2021-01-10-140337.png]]

*** Conclusion
:PROPERTIES:
:ID:       f5384bdc-9100-46eb-81f8-d6c8a8f52ba8
:END:

Now you can have a simple configuration for your local and production
environments to work seamlessly, using local resources instead of remote
resources that might generate costs for the development.

If you want to check out the project code, you can check in my Gitlab here:
https://gitlab.com/rogs/minio-example

See you in the next one!

** How to create a celery task that fills out fields using Django :python::celery::django::docker::dockercompose:
:PROPERTIES:
:EXPORT_FILE_NAME: how-to-create-a-celery-task-that-fills-out-fields-using-django
:EXPORT_DATE: 2020-11-29T15:48:48-03:00
:ID:       f8ed204b-1f57-4c92-8c4f-128658327aed
:END:

Hi everyone!

It's been way too long, I know. In this oportunity, I wanted to talk about
asynchronicity in Django, but first, lets set up the stage: 

Imagine you are working in a library and you have to develop an app that allows
users to register new books using a barcode scanner. The system has to read the
ISBN code and use an external resource to fill in the information (title, pages,
authors, etc.). You don't need the complete book information to continue, so the
external resource can't hold the request.

*How can you process the external request asynchronously?* ğŸ¤” 

For that, we need Celery.

*** What is Celery?
:PROPERTIES:
:ID:       d3f8a2ad-09c2-4ae7-8b84-50210af7a2dc
:END:
[[https://docs.celeryproject.org/en/stable/][Celery]] is a "distributed task queue". Fron their website:

> Celery is a simple, flexible, and reliable distributed system to process vast
amounts of messages, while providing operations with the tools required to
maintain such a system. 

So Celery can get messages from external processes via a broker (like [[https://redis.io/][Redis]]),
and process them.

The best thing is: Django can connect to Celery very easily, and Celery can
access Django models without any problem. Sweet!

*** Lets code!
:PROPERTIES:
:ID:       0e6a021e-ab2a-48d0-92a0-39fd4f7c3409
:END:
Let's assume our project structure is the following:
#+begin_src 
- app/
  - manage.py
  - app/
    - __init__.py
    - settings.py
    - urls.py
#+end_src

**** Celery
:PROPERTIES:
:ID:       77b6e575-bc24-4ad3-b504-74bdef9145d3
:END:
First, we need to set up Celery in Django. Thankfully, [[https://docs.celeryproject.org/en/stable/django/first-steps-with-django.html#using-celery-with-django][Celery has an excellent
documentation]], but the entire process can be summarized to this:

In ~app/app/celery.py~:
#+begin_src python
import os

from celery import Celery

# set the default Django settings module for the 'celery' program.
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "app.settings")

app = Celery("app")

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object("django.conf:settings", namespace="CELERY")

# Load task modules from all registered Django app configs.
app.autodiscover_tasks()


@app.task(bind=True)
def debug_task(self):
    """A debug celery task"""
    print(f"Request: {self.request!r}")
#+end_src

What's going on here?
- First, we set the ~DJANGO_SETTINGS_MODULE~ environment variable
- Then, we instantiate our Celery app using the ~app~ variable.
- Then, we tell Celery to look for celery configurations in the Django settings
  with the ~CELERY~ prefix. We will see this later in the post.
- Finally, we start Celery's ~autodiscover_tasks~. Celery is now going to look for
  ~tasks.py~ files in the Django apps.

In ~/app/app/__init__.py~:
#+begin_src python
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ("celery_app",)
#+end_src

Finally in ~/app/app/settings.py~:
#+begin_src python
...
# Celery
CELERY_BROKER_URL = env.str("CELERY_BROKER_URL")
CELERY_TIMEZONE = env.str("CELERY_TIMEZONE", "America/Montevideo")
CELERY_RESULT_BACKEND = "django-db"
CELERY_CACHE_BACKEND = "django-cache"
...
#+end_src

Here, we can see that the ~CELERY~ prefix is used for all Celery configurations,
because on ~celery.py~ we told Celery the prefix was ~CELERY~

With this, Celery is fully configured. ğŸ‰ 

**** Django
:PROPERTIES:
:ID:       dd40e5c4-7d82-4d3c-b5da-a7c8751b9f70
:END:

First, let's create a ~core~ app. This is going to be used for everything common
in the app
#+begin_src bash
$ python manage.py startapp core
#+end_src

On ~core/models.py~, lets set the following models:
#+begin_src python
"""
Models
"""
import uuid

from django.db import models


class TimeStampMixin(models.Model):
    """
    A base model that all the other models inherit from.
    This is to add created_at and updated_at to every model.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        """Setting up the abstract model class"""

        abstract = True


class BaseAttributesModel(TimeStampMixin):
    """
    A base model that sets up all the attibutes models
    """

    name = models.CharField(max_length=255)
    outside_url = models.URLField()

    def __str__(self):
        return self.name

    class Meta:
        abstract = True
#+end_src

Then, let's create a new app for our books:
#+begin_src bash
python manage.py startapp books
#+end_src

And on ~books/models.py~, let's create the following models:
#+begin_src python
"""
Books models
"""
from django.db import models

from core.models import TimeStampMixin, BaseAttributesModel


class Author(BaseAttributesModel):
    """Defines the Author model"""


class People(BaseAttributesModel):
    """Defines the People model"""


class Subject(BaseAttributesModel):
    """Defines the Subject model"""


class Book(TimeStampMixin):
    """Defines the Book model"""

    isbn = models.CharField(max_length=13, unique=True)
    title = models.CharField(max_length=255, blank=True, null=True)
    pages = models.IntegerField(default=0)
    publish_date = models.CharField(max_length=255, blank=True, null=True)
    outside_id = models.CharField(max_length=255, blank=True, null=True)
    outside_url = models.URLField(blank=True, null=True)
    author = models.ManyToManyField(Author, related_name="books")
    person = models.ManyToManyField(People, related_name="books")
    subject = models.ManyToManyField(Subject, related_name="books")

    def __str__(self):
        return f"{self.title} - {self.isbn}"
#+end_src

~Author~, ~People~, and ~Subject~ are all ~BaseAttributesModel~, so their fields
come from the class we defined on ~core/models.py~.

For ~Book~ we add all the fields we need, plus a ~many_to_many~ with Author,
People and Subjects. Because:

- /Books can have many authors, and many authors can have many books/
Example: [[https://www.epicreads.com/blog/ya-books-multiple-authors/][27 Books by Multiple Authors That Prove the More, the Merrier]]
- /Books can have many persons, and many persons can have many books/
Example: Ron Weasley is in several /Harry Potter/ books
- /Books can have many subjects, and many subjects can have many books/
Example: A book can be a /comedy/, /fiction/, and /mystery/ at the same time

Let's create ~books/serializers.py~:
#+begin_src python
"""
Serializers for the Books
"""
from django.db.utils import IntegrityError
from rest_framework import serializers

from books.models import Book, Author, People, Subject
from books.tasks import get_books_information


class AuthorInBookSerializer(serializers.ModelSerializer):
    """Serializer for the Author objects inside Book"""

    class Meta:
        model = Author
        fields = ("id", "name")


class PeopleInBookSerializer(serializers.ModelSerializer):
    """Serializer for the People objects inside Book"""

    class Meta:
        model = People
        fields = ("id", "name")


class SubjectInBookSerializer(serializers.ModelSerializer):
    """Serializer for the Subject objects inside Book"""

    class Meta:
        model = Subject
        fields = ("id", "name")


class BookSerializer(serializers.ModelSerializer):
    """Serializer for the Book objects"""

    author = AuthorInBookSerializer(many=True, read_only=True)
    person = PeopleInBookSerializer(many=True, read_only=True)
    subject = SubjectInBookSerializer(many=True, read_only=True)

    class Meta:
        model = Book
        fields = "__all__"


class BulkBookSerializer(serializers.Serializer):
    """Serializer for bulk book creating"""

    isbn = serializers.ListField()

    def create(self, validated_data):
        return_dict = {"isbn": []}
        for isbn in validated_data["isbn"]:
            try:
                Book.objects.create(isbn=isbn)
                return_dict["isbn"].append(isbn)
            except IntegrityError as error:
                pass

        return return_dict

    def update(self, instance, validated_data):
        """The update method needs to be overwritten on
        serializers.Serializer. Since we don't need it, let's just
        pass it"""
        pass


class BaseAttributesSerializer(serializers.ModelSerializer):
    """A base serializer for the attributes objects"""

    books = BookSerializer(many=True, read_only=True)


class AuthorSerializer(BaseAttributesSerializer):
    """Serializer for the Author objects"""

    class Meta:
        model = Author
        fields = ("id", "name", "outside_url", "books")


class PeopleSerializer(BaseAttributesSerializer):
    """Serializer for the Author objects"""

    class Meta:
        model = People
        fields = ("id", "name", "outside_url", "books")


class SubjectSerializer(BaseAttributesSerializer):
    """Serializer for the Author objects"""

    class Meta:
        model = Subject
        fields = ("id", "name", "outside_url", "books")

#+end_src
The most important serializer here is ~BulkBookSerializer~. It's going to get an
ISBN list and then bulk create them in the DB.

On ~books/views.py~, we can set the following views:
#+begin_src python
"""
Views for the Books
"""
from rest_framework import viewsets, mixins, generics
from rest_framework.permissions import AllowAny

from books.models import Book, Author, People, Subject
from books.serializers import (
    BookSerializer,
    BulkBookSerializer,
    AuthorSerializer,
    PeopleSerializer,
    SubjectSerializer,
)


class BookViewSet(
    viewsets.GenericViewSet,
    mixins.ListModelMixin,
    mixins.RetrieveModelMixin,
):
    """
    A view to list Books and retrieve books by ID
    """

    permission_classes = (AllowAny,)
    queryset = Book.objects.all()
    serializer_class = BookSerializer


class AuthorViewSet(
    viewsets.GenericViewSet,
    mixins.ListModelMixin,
    mixins.RetrieveModelMixin,
):
    """
    A view to list Authors and retrieve authors by ID
    """

    permission_classes = (AllowAny,)
    queryset = Author.objects.all()
    serializer_class = AuthorSerializer


class PeopleViewSet(
    viewsets.GenericViewSet,
    mixins.ListModelMixin,
    mixins.RetrieveModelMixin,
):
    """
    A view to list People and retrieve people by ID
    """

    permission_classes = (AllowAny,)
    queryset = People.objects.all()
    serializer_class = PeopleSerializer


class SubjectViewSet(
    viewsets.GenericViewSet,
    mixins.ListModelMixin,
    mixins.RetrieveModelMixin,
):
    """
    A view to list Subject and retrieve subject by ID
    """

    permission_classes = (AllowAny,)
    queryset = Subject.objects.all()
    serializer_class = SubjectSerializer


class BulkCreateBook(generics.CreateAPIView):
    """A view to bulk create books"""

    permission_classes = (AllowAny,)
    queryset = Book.objects.all()
    serializer_class = BulkBookSerializer
#+end_src

Easy enough, endpoints for getting books, authors, people and subjects and an
endpoint to post ISBN codes in a list.

We can check swagger to see all the endpoints created:

[[/2020-11-29-115634.png]]

Now, *how are we going to get all the data?* ğŸ¤” 

*** Creating a Celery task
:PROPERTIES:
:ID:       ac678884-7d0e-46fd-91e2-ec0e0edd12a9
:END:
Now that we have our project structure done, we need to create the asynchronous
task Celery is going to run to populate our fields.

To get the information, we are going to use the [[https://openlibrary.org/dev/docs/api/books"""][OpenLibrary API]].

First, we need to create ~books/tasks.py~:
#+begin_src python
"""
Celery tasks
"""
import requests
from celery import shared_task

from books.models import Book, Author, People, Subject


def get_book_info(isbn):
    """Gets a book information by using its ISBN.
    More info here https://openlibrary.org/dev/docs/api/books"""
    return requests.get(
        f"https://openlibrary.org/api/books?jscmd=data&format=json&bibkeys=ISBN:{isbn}"
    ).json()


def generate_many_to_many(model, iterable):
    """Generates the many to many relationships to books"""
    return_items = []
    for item in iterable:
        relation = model.objects.get_or_create(
            name=item["name"], outside_url=item["url"]
        )
        return_items.append(relation)
    return return_items


@shared_task
def get_books_information(isbn):
    """Gets a book information"""

    # First, we get the book information by its isbn
    book_info = get_book_info(isbn)

    if len(book_info) > 0:
        # Then, we need to access the json itself. Since the first key is dynamic,
        # we get it by accessing the json keys
        key = list(book_info.keys())[0]
        book_info = book_info[key]

        # Since the book was created on the Serializer, we get the book to edit
        book = Book.objects.get(isbn=isbn)

        # Set the fields we want from the API into the Book
        book.title = book_info["title"]
        book.publish_date = book_info["publish_date"]
        book.outside_id = book_info["key"]
        book.outside_url = book_info["url"]

        # For the optional fields, we try to get them first
        try:
            book.pages = book_info["number_of_pages"]
        except:
            book.pages = 0

        try:
            authors = book_info["authors"]
        except:
            authors = []

        try:
            people = book_info["subject_people"]
        except:
            people = []

        try:
            subjects = book_info["subjects"]
        except:
            subjects = []

        # And generate the appropiate many_to_many relationships
        authors_info = generate_many_to_many(Author, authors)
        people_info = generate_many_to_many(People, people)
        subjects_info = generate_many_to_many(Subject, subjects)

        # Once the relationships are generated, we save them in the book instance
        for author in authors_info:
            book.author.add(author[0])

        for person in people_info:
            book.person.add(person[0])

        for subject in subjects_info:
            book.subject.add(subject[0])

        # Finally, we save the Book
        book.save()

    else:
        raise ValueError("Book not found")
#+end_src

So when are we going to run this task? We need to run it in the *serializer*.

On ~books/serializers.py~:
#+begin_src python
from books.tasks import get_books_information
...
class BulkBookSerializer(serializers.Serializer):
    """Serializer for bulk book creating"""

    isbn = serializers.ListField()

    def create(self, validated_data):
        return_dict = {"isbn": []}
        for isbn in validated_data["isbn"]:
            try:
                Book.objects.create(isbn=isbn)
                # We need to add this line
                get_books_information.delay(isbn)
                #################################
                return_dict["isbn"].append(isbn)
            except IntegrityError as error:
                pass

        return return_dict

    def update(self, instance, validated_data):
        pass
#+end_src

To trigger the Celery tasks, we need to call our function with the ~delay~
function, which has been added by the ~shared_task~ decorator. This tells Celery
to start running the task in the background since we don't need the result
right now.

*** Docker configuration
:PROPERTIES:
:ID:       3d992b01-11f9-488c-9781-dcddfcf6fe88
:END:
There are a lot of moving parts we need for this to work, so I created a
~docker-compose~ configuration to help with the stack. I'm using the package
[[https://github.com/joke2k/django-environ][django-environ]] to handle all environment variables.

On ~docker-compose.yml~:
#+begin_src yaml
version: "3.7"

x-common-variables: &common-variables
  DJANGO_SETTINGS_MODULE: "app.settings"
  CELERY_BROKER_URL: "redis://redis:6379"
  DEFAULT_DATABASE: "psql://postgres:postgres@db:5432/app"
  DEBUG: "True"
  ALLOWED_HOSTS: "*,test"
  SECRET_KEY: "this-is-a-secret-key-shhhhh"

services:
  app:
    build:
      context: .
    volumes:
      - ./app:/app
    environment:
      <<: *common-variables
    ports:
      - 8000:8000
    command: >
      sh -c "python manage.py migrate &&
             python manage.py runserver 0.0.0.0:8000"
    depends_on:
      - db
      - redis

  celery-worker:
    build:
      context: .
    volumes:
      - ./app:/app
    environment:
      <<: *common-variables
    command: celery --app app worker -l info
    depends_on:
      - db
      - redis

  db:
    image: postgres:12.4-alpine
    environment:
      - POSTGRES_DB=app
      - POSRGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres

  redis:
    image: redis:6.0.8-alpine

#+end_src
This is going to set our app, DB, Redis, and most importantly our celery-worker
instance. To run Celery, we need to execute:
#+begin_src bash
$ celery --app app worker -l info
#+end_src

So we are going to run that command on a separate docker instance

*** Testing it out
:PROPERTIES:
:ID:       50e6cc5d-848b-4d73-a4b6-1bfd23bf86f4
:END:
If we run
#+begin_src bash
$ docker-compose up
#+end_src

on our project root folder, the project should come up as usual. You should be
able to open http://localhost:8000/admin and enter the admin panel.

To test the app, you can use a curl command from the terminal:
#+begin_src bash
curl -X POST "http://localhost:8000/books/bulk-create" -H  "accept: application/json" \
    -H  "Content-Type: application/json" -d "{  \"isbn\": [ \"9780345418913\", \
    \"9780451524935\", \"9780451526342\", \"9781101990322\", \"9780143133438\"   ]}"
#+end_src
[[/2020-11-29-124654.png]]

This call lasted 147ms, according to my terminal.

This should return instantly, creating 15 new books and 15 new Celery tasks, one
for each book. You can also see tasks results in the Django admin using the
~django-celery-results~ package, check its [[https://docs.celeryproject.org/en/stable/django/first-steps-with-django.html#django-celery-results-using-the-django-orm-cache-as-a-result-backend][documentation]].

[[/2020-11-29-124734.png]]

Celery tasks list, using ~django-celery-results~

[[/2020-11-29-124751.png]]

Created and processed books list

[[/2020-11-29-124813.png]]

Single book information

[[/2020-11-29-124834.png]]

People in books

[[/2020-11-29-124851.png]]

Authors

[[/2020-11-29-124906.png]]

Themes

And also, you can interact with the endpoints to search by author, theme,
people, and book. This should change depending on how you created your URLs.

*** That's it!
:PROPERTIES:
:ID:       e7cf2cfe-25ae-472d-b4a2-d154834cce98
:END:
This surely was a *LONG* one, but it has been a very good one in my opinion.
I've used Celery in the past for multiple things, from sending emails in the
background to triggering scraping jobs and [[https://docs.celeryproject.org/en/stable/userguide/periodic-tasks.html#using-custom-scheduler-classes][running scheduled tasks]] (like a [[https://en.wikipedia.org/wiki/Cron][unix
cronjob]]) 

You can check the complete project in my GitLab here: https://gitlab.com/rogs/books-app

If you have any doubts, let me know! I always answer emails and/or messages.
** How I got a residency appointment thanks to Python, Selenium and Telegram :python:selenium:telegram:
:PROPERTIES:
:EXPORT_FILE_NAME: how-i-got-a-residency-appointment-thanks-to-python-and-selenium
:EXPORT_DATE: 2020-08-02
:ID:       b7da6c10-ca61-4839-9074-039e11a4475d
:END:
Hello everyone

As some of you might know, I'm a Venezuelan ğŸ‡»ğŸ‡ª living in Montevideo, Uruguay ğŸ‡ºğŸ‡¾.
I've been living here for almost a year, but because of the pandemic my
residency appointments have slowed down to a crawl, and in the middle of the
quarantine they added a new appointment system. Before, there were no
appointments, you just had to get there early and wait for the secretary to
review your files and assign someone to attend you. But now, they had
implemented an appointment system that you could do from the comfort of your own
home/office. There was just one issue: *there were never appointments available*.

That was a little stressful. I was developing a small /tick/ by checking the
site multiple times a day, with no luck. But then, I decided I wanted to do a
bot that checks the site for me, that way I could just forget about it and let
the computers do it for me.

*** Tech
:PROPERTIES:
:ID:       b762da5f-9a5a-41ec-982d-ea864a661f5b
:END:
**** Selenium
:PROPERTIES:
:ID:       12fcf6c3-a167-4d7d-971e-614b1944078d
:END:
I had some experience with Selenium in the past because I had to run automated
tests on an Android application, but I had never used it for the web. I knew it
supported Firefox and had an extensive API to interact with websites. In the
end, I just had to inspect the HTML and search for the "No appointments
available" error message. If the message wasn't there, I needed a way to be
notified so I can set my appointment as fast as possible.
**** Telegram Bot API
:PROPERTIES:
:ID:       221b1f01-dfa7-46ae-b162-6299c8d69159
:END:
Telegram was my goto because I have a lot of experience with it. It has a
stupidly easy API that allows for superb bot management. I just needed the bot
to send me a message whenever the "No appointments available" message wasn't
found on the site.

*** The plan
:PROPERTIES:
:ID:       422aac40-f61b-4b7c-bd98-f68c2a0340da
:END:
Here comes the juicy part: How is everything going to work together?

I divided the work into four parts:
1) Inspecting the site
2) Finding the error message on the site
3) Sending the message if nothing was found
4) Deploy the job with a cronjob on my VPS
  
*** Inspecting the site
:PROPERTIES:
:ID:       df519909-0814-435d-9bf2-bf21b27328aa
:END:
Here is the site I needed to inspect:
- On the first site, I need to click the bottom button. By inspecting the HTML,
  I found out that its name is ~form:botonElegirHora~
  [[/2020-08-02-171251.png]]
- When the button is clicked, it loads a second page that has an error message
  if no appointments are found. The ID of that message is ~form:warnSinCupos~.
  [[/2020-08-02-162205.png]]
 
*** Using Selenium to find the error message
:PROPERTIES:
:ID:       aa6b4101-d8ab-4540-bfad-f6b70feb0e05
:END:
First, I needed to define the browser session and its settings. I wanted to run
it in headless mode so no X session is needed:
#+BEGIN_SRC python
from selenium import webdriver
from selenium.webdriver.firefox.options import Options

options = Options()
options.headless = True
d = webdriver.Firefox(options=options)
#+END_SRC

Then, I opened the site, looked for the button (~form:botonElegirHora~) and
clicked it
#+BEGIN_SRC python
# This is the website I wanted to scrape
d.get('https://sae.mec.gub.uy/sae/agendarReserva/Paso1.xhtml?e=9&a=7&r=13')
elem = d.find_element_by_name('form:botonElegirHora')
elem.click()
#+END_SRC

And on the new page, I looked for the error message (~form:warnSinCupos~)
#+BEGIN_SRC python
try:
    warning_message = d.find_element_by_id('form:warnSinCupos')
except Exception:
    pass
#+END_SRC

This was working exactly how I wanted: It opened a new browser session, opened
the site, clicked the button, and then looked for the message. For now, if the
message wasn't found, it does nothing. Now, the script needs to send me a
message if the warning message wasn't found on the page.

*** Using Telegram to send a message if the warning message wasn't found
:PROPERTIES:
:ID:       2a0fb5d3-d316-4ad0-9d46-58960c0ecb5e
:END:
The Telegram bot API has a very simple way to send messages. If you want to read
more about their API, you can check it [[https://core.telegram.org/][here]].

There are a few steps you need to follow to get a Telegram bot:
1) First, you need to "talk" to the [[https://core.telegram.org/bots#6-botfather][Botfather]] to create the bot.
2) Then, you need to find your Telegram Chat ID. There are a few bots that can help
  you with that, I personally use ~@get_id_bot~.
3) Once you have the ID, you should read the ~sendMessage~ API, since that's the
   only one we need now. You can check it [[https://core.telegram.org/bots/api#sendmessage][here]].

So, by using the Telegram documentation, I came up with the following code:
#+BEGIN_SRC python
import requests

chat_id = # Insert your chat ID here
telegram_bot_id = # Insert your Telegram bot ID here
telegram_data = {
    "chat_id": chat_id
    "parse_mode": "HTML",
    "text": ("<b>Hay citas!</b>\nHay citas en el registro civil, para "
             f"entrar ve a {SAE_URL}")
}
requests.post('https://api.telegram.org/bot{telegram_bot_id}/sendmessage', data=telegram_data)
#+END_SRC

*** The complete script
:PROPERTIES:
:ID:       4fdd292f-661f-424d-9c07-6fbcfa34fad7
:END:
I added a few loggers and environment variables and voilÃ¡! Here is the complete code:
#+BEGIN_SRC python
#!/usr/bin/env python3

import os
import requests
from datetime import datetime

from selenium import webdriver
from selenium.webdriver.firefox.options import Options

from dotenv import load_dotenv

load_dotenv() # This loads the environmental variables from the .env file in the root folder

TELEGRAM_BOT_ID = os.environ.get('TELEGRAM_BOT_ID')
TELEGRAM_CHAT_ID = os.environ.get('TELEGRAM_CHAT_ID')
SAE_URL = 'https://sae.mec.gub.uy/sae/agendarReserva/Paso1.xhtml?e=9&a=7&r=13'

options = Options()
options.headless = True
d = webdriver.Firefox(options=options)
d.get(SAE_URL)
print(f'Headless Firefox Initialized {datetime.now()}')
elem = d.find_element_by_name('form:botonElegirHora')
elem.click()
try:
    warning_message = d.find_element_by_id('form:warnSinCupos')
    print('No dates yet')
    print('------------------------------')
except Exception:
    telegram_data = {
        "chat_id": TELEGRAM_CHAT_ID,
        "parse_mode": "HTML",
        "text": ("<b>Hay citas!</b>\nHay citas en el registro civil, para "
                 f"entrar ve a {SAE_URL}")
    }
    requests.post('https://api.telegram.org/bot'
                  f'{TELEGRAM_BOT_ID}/sendmessage', data=telegram_data)
    print('Dates found!')
d.close() # To close the browser connection
#+END_SRC

Only one more thing to do, to deploy everything to my VPS

*** Deploy and testing on the VPS
:PROPERTIES:
:ID:       f57694d6-904b-4c51-8560-2a1ad562e991
:END:
This was very easy. I just needed to pull my git repo, install the
~requirements.txt~ and set a new cron to run every 10 minutes and check the
site. The cron settings I used where:
#+BEGIN_SRC bash
*/10 * * * * /usr/bin/python3 /my/script/location/registro-civil-scraper/app.py >> /my/script/location/registro-civil-scraper/log.txt
#+END_SRC
The ~>> /my/script/location/registro-civil-scraper/log.txt~ part is to keep the logs on a new file.

*** Did it work?
:PROPERTIES:
:ID:       56cff142-4ab4-4f31-87f2-b4124e283158
:END:
Yes! And it worked perfectly. I got a message the following day at 21:00
(weirdly enough, that's 0:00GMT, so maybe they have their servers at GMT time
and it opens new appointments at 0:00).
[[/2020-08-02-170458.png]]

*** Conclusion
:PROPERTIES:
:ID:       1a6dcfca-aaf4-406f-8800-57ffa7832ddf
:END:
I always loved to use programming to solve simple problems. With this script, I
didn't need to check the site every couple of hours to get an appointment, and
sincerely, I wasn't going to check past 19:00, so I would've never found it by
my own.

My brother is having similar issues in Argentina, and when I showed him this, he
said one of the funniest phrases I've heard about my profession:

> /"Programmers could take over the world, but they are too lazy"/

I lol'd way too hard at that.

I loved Selenium and how it worked. Recently I created a crawler using Selenium,
Redis, peewee, and Postgres, so stay tuned if you want to know more about that.

In the meantime, if you want to check the complete script, you can see it on my
Gitlab: https://gitlab.com/rogs/registro-civil-scraper

** Introducing: YAMS (Yet Another Media Server)! :docker:dockercompose:announcements:opensource:
:PROPERTIES:
:ID:       54640f47-b06e-47e0-93d8-ef00d14d2a70
:EXPORT_FILE_NAME: introducing-yams
:EXPORT_DATE: 2023-01-20T09:57:48-03:00
:END:
Hello internet ğŸ˜

I'm here with a *big* announcement: I have created a bash script that installs my entire media server,
fast and easy ğŸ‰

[[https://yams.media/install-yams.gif]]

*** TL;DR
:PROPERTIES:
:ID:       efd21b9f-fe0b-4cd8-8109-85e248a0ed83
:END:
I've created YAMS. A full media server that allows you to download and categorize your shows/movies.

Go to YAMS's website here: http://yams.media or check it on Gitlab here: https://gitlab.com/rogs/yams.

*** A little history
:PROPERTIES:
:ID:       2c03004c-b143-483c-a18e-da8858dae78d
:END:
When I first set up my media server, it took me ~2 weeks to install, configure and understand how it's
supposed to work: Linking Sonarr, Radarr, Jackett together, choosing a good BitTorrent downloader,
understanding all the moving pieces, choosing Emby, etc. My plan with YAMS is to make it easier
for noobs (and lazy people like me) to set up their media servers super easily.

I have been working on YAMS for ~2 weeks. The docker-compose file has existed for almost 2 years but
without any configuration instructions. Basically, you had to do everything manually, and if you didn't
have any experience with docker, docker-compose, or any of the services included, it was very cumbersome
to configure and understand how everything worked together.

So basically, I'm encapsulating my experience for anyone that wants to use it. If you don't like it, at
least you might learn something from my experience, YAMS's [[https://git.rogs.me/yams.git/tree/docker-compose.example.yaml][docker-compose file]] or its [[https://yams.media/config/][configuration
tutorial]].

This is my first (and hopefully not last!) piece of open source software. I know it's just a [[https://git.rogs.me/yams.git/tree/install.sh][bash script]]
that sets up a [[https://git.rogs.me/yams.git/tree/docker-compose.example.yaml][docker-compose]] file, but seeing how my friends are using it and giving me feedback is
exciting and addictive!

*** Why?
:PROPERTIES:
:ID:       2ff80f32-8bda-4ac9-9e73-2797c30b795a
:END:
In 2019 I wanted a setup that my non-technical girlfriend could use without any problems, so I started
designing my media server using multiple open source projects and running them on top of docker.

Today I would like to say it works very well ğŸ˜ And most importantly, I accomplished my goal: My
girlfriend uses it regularly and I even was able to expand it to my mother, who lives 5000kms from me.

But then, my friends saw my setup...

On June 2022 I had a small "party" with my work friends at my apartment, and all of them were very
impressed with my home server setup:

- "Sonarr" to index shows.
- "Radarr" to index movies.
- "qBittorrent" to download torrents.
- "Emby" to serve the server.

They kept telling me to create a tutorial, or just teach them how to set one up themselves.

I tried to explain the full setup to one of them, but explaining how everything connected and worked
together was a big pain. That is what led me to create this script and configuration tutorial, so anyone
regardless of their tech background and knowledge could start a basic media server.

So basically, my friends pushed me to build this script and documentation, so they (and now anyone!)
could build it on their own home servers.

*** Ok, sounds cool. What did you do then?
:PROPERTIES:
:ID:       a3f12499-f30e-49b7-bc02-008ae2216ac7
:END:

[[https://git.rogs.me/yams.git/tree/install.sh][A bash script]] that asks basic questions to the user and sets up the ultimate media server, with
[[https://yams.media/config/][configuration instructions included]]! (That's the part I really *REALLY* enjoyed!)

*** What's included with YAMS?
:PROPERTIES:
:ID:       5123a57d-4bf6-4415-898b-a74ea70d0912
:END:
This script installs the following software:

- [[https://sonarr.tv/][Sonarr]]
- [[https://radarr.video/][Radarr]]
- [[https://emby.media/][Emby]]
- [[https://www.qbittorrent.org/][qBittorrent]]
- [[https://www.bazarr.media/][Bazarr]]
- [[https://github.com/Jackett/Jackett][Jackett]]
- [[https://github.com/qdm12/gluetun][gluetun]]

This combination allows you to create a fully functional media server that is going to download,
categorize, subtitle, and serve your favorite shows and movies.

*** Features
:PROPERTIES:
:ID:       9ec586bb-7b96-48b2-b14e-86e3b5ac4d18
:END:
In no particular order:
- *Automatic shows/movies download*: Just add your shows and movies to the watch list and it should
  automatically download the files when they are available.
- *Automatic classification and organization*: Your media files should be completely organized by default.
- *Automatic subtitles download*: Self-explanatory. Your media server should automatically download
  subtitles in the languages you choose if they are available.
- *Support for Web, Android, iOS, Android TV, and whatever that can support Emby*: Since we are
  using Emby, you should be able to watch your favorite media almost anywhere.
*** Conclusion
:PROPERTIES:
:ID:       afc0e352-8336-4537-a221-eeaf28f04276
:END:
You can go to YAMS's website here: https://yams.media.

I'm *very* proud of how YAMS is turning out! If you end up using it on your server, I just want to tell
you *THANK YOU* ğŸ™‡ from the bottom of my heart. You are **AWESOME!**

Feedback is GREATLY appreciated (the VPN was added from the feedback!). I'm here to support YAMS for the
long run, so I would like suggestions on how to improve the setup/website/configuration steps.

You can always submit [[https://gitlab.com/rogs/yams/-/issues/new][issues]] on Gitlab if you find any problems, or you can [[/contact][contact]] me directly (email
preferred!).

** Claude Code from the beach: My remote coding setup with mosh, tmux and ntfy :programming:claude:remotedev:tmux:mosh:ntfy:
:PROPERTIES:
:EXPORT_FILE_NAME: claude-code-from-the-beach-remote-coding-setup
:EXPORT_DATE: 2026-02-10
:ID:       09b14b0b-eb4b-43f4-8ad9-9462e29515c4
:EXPORT_HUGO_PAIRED_SHORTCODES: img
:END:

#+begin_export hugo
{{< img class="beach" src="/1000121647.jpg" caption="The view two blocks from my apartment" >}}
#+end_export

I recently read [[https://granda.org/en/2026/01/02/claude-code-on-the-go/][this awesome post]] by Granda about running Claude Code from a
phone, and I thought: /I need this in my life/. The idea is simple: kick off a
Claude Code task, pocket the phone, go do something fun, and get a notification
when Claude needs your help or finishes working. Async development from anywhere.

But my setup is a bit different from his. I'm not using Tailscale or a cloud VM.
I already have a WireGuard VPN connecting my devices, a home server, and a
self-hosted ntfy instance. So I built my own version, tailored to my
infrastructure.

Here's the high-level architecture:

#+begin_src
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      mosh       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      ssh        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phone   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ Home Server â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Work PC   â”‚
â”‚ (Termux) â”‚    WireGuard    â”‚  (Jump Box) â”‚      LAN        â”‚(Claude Code)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â–²                                                             â”‚
      â”‚                          ntfy (HTTPS)                       â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#+end_src

The loop is: I'm at the beach, I type ~cc~ on my phone, I land in a tmux session
with Claude Code. I give it a task, pocket the phone, and go back to whatever I
was doing. When Claude has a question or finishes, my phone buzzes. I pull it
out, respond, pocket it again. Development fits into the gaps of the day.

And here's what the async development loop looks like in practice:

#+begin_src
  ğŸ“± Phone                    ğŸ’» Work PC                   ğŸ”” ntfy
    â”‚                            â”‚                           â”‚
    â”‚â”€â”€â”€â”€ type 'cc' â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                           â”‚
    â”‚â”€â”€â”€â”€ give Claude a task â”€â”€â”€â–¶â”‚                           â”‚
    â”‚                            â”‚                           â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚                           â”‚
    â”‚   â”‚ pocket phone    â”‚      â”‚                           â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚                           â”‚
    â”‚                            â”‚                           â”‚
    â”‚                            â”‚â”€â”€ hook fires â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
    â”‚â—€â”€â”€ "Claude needs input" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                            â”‚                           â”‚
    â”‚â”€â”€â”€â”€ respond â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                           â”‚
    â”‚                            â”‚                           â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚                           â”‚
    â”‚   â”‚ pocket phone    â”‚      â”‚                           â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚                           â”‚
    â”‚                            â”‚                           â”‚
    â”‚                            â”‚â”€â”€ hook fires â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
    â”‚â—€â”€â”€ "Task complete" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                            â”‚                           â”‚
    â”‚â”€â”€â”€â”€ review, approve PR â”€â”€â”€â–¶â”‚                           â”‚
    â”‚                            â”‚                           â”‚
#+end_src

*** Why not just use the blog post's setup?
:PROPERTIES:
:ID:       ace61eeb-24d4-4202-aa1a-f488caf34ca9
:END:

Granda's setup uses Tailscale for VPN, a Vultr cloud VM, Termius as the mobile
terminal, and Poke for notifications. It's clean and it works. But I had
different constraints:

- I already have a *WireGuard VPN* running ~wg-quick~ on a server that connects all my devices. No need
  for Tailscale.
- I didn't want to pay for a cloud VM. My work PC is more than powerful enough to
  run Claude Code.
- I self-host *ntfy* for notifications, so no need for Poke or any external
  notification service.
- I use *Termux* (open-source), not Termius.

If you don't have this kind of infrastructure already, Granda's approach is
probably simpler. But if you're the kind of person who already has a WireGuard
mesh and self-hosted services, this guide is for you.

*** The pieces
:PROPERTIES:
:ID:       ef0bbdf7-a0ff-4289-9fc7-0851bd36d42a
:END:

| Component   | Purpose                             | Alternatives                     |
|-------------+-------------------------------------+----------------------------------|
| WireGuard   | VPN to reach home network           | Tailscale, Zerotier, Nebula      |
| mosh        | Network-resilient shell (phone leg) | Eternal Terminal (et), plain SSH |
| SSH         | Secure connection (LAN leg)         | mosh (if you want it end-to-end) |
| tmux        | Session persistence                 | screen, zellij                   |
| Claude Code | The actual work                     | â€”                                |
| ntfy        | Push notifications                  | Pushover, Gotify, Poke, Telegram |
| Termux      | Terminal emulator                   | Termius, JuiceSSH, ConnectBot    |
| fish shell  | Shell on all machines               | zsh, bash                        |

The key insight is that you need *two different types of resilience*: mosh
handles the flaky mobile connection (WiFi to cellular transitions, dead zones,
phone sleeping), while tmux handles session persistence (close the app, reopen
hours later, everything's still there). Together they make mobile development
actually viable.

*** Why the double SSH? Why not make the work PC a WireGuard peer?
:PROPERTIES:
:ID:       dde96e41-601b-4817-9ed4-eefaa2010798
:END:

You might be wondering: if I already have a WireGuard network, why not just add
the work PC as a peer and mosh straight into it from my phone?

The short answer: *it's my employer's machine*. It has monitoring software
installed: screen grabbing, endpoint policies, the works. Installing WireGuard
on it would mean running a VPN client that tunnels traffic through my personal
infrastructure, which is the kind of thing that raises flags with IT security. I
don't want to deal with that conversation.

SSH, on the other hand, is standard dev tooling. An openssh-server on a Linux
machine is about as unremarkable as it gets.

So instead, my home server acts as a jump box. My phone connects to the home
server over WireGuard (that's all personal infrastructure, no employer
involvement), and then the home server SSHs into the work PC over the local
network. The work PC only needs an SSH server, no VPN client, no weird tunnels,
nothing that would make the monitoring software blink.

#+begin_src
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚               My Infrastructure                  â”‚
    â”‚                                                  â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    WireGuard   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚   Phone   â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ WG Server    â”‚   â”‚
    â”‚  â”‚  (peer)   â”‚    tunnel      â”‚              â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚        â”‚                             â”‚           â”‚
    â”‚        â”‚ mosh            WireGuard   â”‚           â”‚
    â”‚        â”‚ (through tunnel)  tunnel    â”‚           â”‚
    â”‚        â”‚                             â”‚           â”‚
    â”‚        â–¼                             â–¼           â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
    â”‚  â”‚ Home Server  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚  â”‚   (peer)     â”‚                                â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
    â”‚         â”‚                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â”‚ ssh (LAN)
              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         â–¼                                        â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
    â”‚  â”‚ Work PC    â”‚                                  â”‚
    â”‚  â”‚ (SSH only) â”‚        Employer Infrastructure   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#+end_src

As a bonus, this means the work PC has zero exposure to the public internet. It
only accepts SSH from machines on my local network. Defense in depth.

*** Phase 1: SSH server on the work PC
:PROPERTIES:
:ID:       48f8011f-a01e-42ab-8cff-ee97821827b4
:END:

My work PC is running Ubuntu 24.04. First thing: install and harden the SSH
server.

#+begin_src bash
sudo apt update && sudo apt install -y openssh-server
sudo systemctl enable ssh
#+end_src

Note: on Ubuntu 24.04 the service is called ~ssh~, not ~sshd~. This tripped me
up.

Then harden the config. I created ~/etc/ssh/sshd_config~ with:

#+begin_src bash
PermitRootLogin no
PasswordAuthentication no
KbdInteractiveAuthentication no
PubkeyAuthentication yes
AllowAgentForwarding no
X11Forwarding no
UsePAM yes
MaxAuthTries 3
ClientAliveInterval 60
ClientAliveCountMax 3
#+end_src

Key-only auth, no root login, no password auth. Since the machine is only
accessible through my local network, this is plenty secure.

**** Setting up SSH keys for the home server â†’ work PC connection
:PROPERTIES:
:ID:       c7aecfc7-27a1-48e2-a0d2-6e67cc42471f
:END:

On the *home server*, generate a key pair if you don't already have one:

#+begin_src bash
ssh-keygen -t ed25519 -C "homeserver->workpc"
#+end_src

Accept the default path (~/.ssh/id_ed25519~). Then copy the public key to the
work PC:

#+begin_src bash
ssh-copy-id roger@<work-pc-ip>
#+end_src

Now restart sshd:

#+begin_src bash
sudo systemctl restart ssh
#+end_src

*Important*: Test the SSH connection from your home server /before/ closing your
current session. Don't lock yourself out.

#+begin_src bash
# From the home server
ssh roger@<work-pc-ip>
#+end_src

If it drops you into a shell without asking for a password, you're golden.

**** Alternative: Tailscale
:PROPERTIES:
:ID:       90f63d4d-8be4-476d-afad-24198b22e8c7
:END:

If you don't have a WireGuard setup, [[https://tailscale.com/][Tailscale]] is the easiest way to get a
private network going. Install it on your phone and your work PC, and they can
see each other directly. No jump host needed, no port forwarding, no firewall
rules. It's honestly magic for this kind of thing. The only reason I don't use it
is because I already had WireGuard running before Tailscale existed.

*** Phase 2: tmux + auto-attach
:PROPERTIES:
:ID:       fb6d0737-5f8c-43cc-a1d8-ee07233f6228
:END:

The idea here is simple: every time I SSH into the work PC, I want to land
directly in a tmux session. If the session already exists, attach to it. If not,
create one.

First, ~~/.tmux.conf~:

#+begin_src bash
# mouse support (essential for thumbing it on the phone)
set -g mouse on

# start window numbering at 1 (easier to reach on phone keyboard)
set -g base-index 1
setw -g pane-base-index 1

# status bar
set -g status-style 'bg=colour235 fg=colour136'
set -g status-left '#[fg=colour46][#S] '
set -g status-right '#[fg=colour166]%H:%M'
set -g status-left-length 30

# longer scrollback
set -g history-limit 50000

# reduce escape delay (makes editors snappier over SSH)
set -sg escape-time 10

# keep sessions alive
set -g destroy-unattached off
#+end_src

Mouse support is *essential* when you're using your phone. Being able to tap to
select panes, scroll with your finger, and resize things makes a massive
difference.

Then in ~~/.config/fish/config.fish~ on the work PC:

#+begin_src fish
if set -q SSH_CONNECTION; and not set -q TMUX
    tmux attach -t claude 2>/dev/null; or tmux new -s claude -c ~/projects/my-app
end
#+end_src

This checks for ~SSH_CONNECTION~ so it only auto-attaches when I'm remoting in.
When I'm physically at the machine, I use the terminal normally without tmux.
This distinction becomes important later for notifications.

*** Phase 3: Claude Code hooks + ntfy
:PROPERTIES:
:ID:       2b04937c-6114-464f-85ca-666936457b46
:END:

This is the fun part. Claude Code has a [[https://docs.anthropic.com/en/docs/claude-code/hooks][hook system]] that lets you run commands
when certain events happen. We're going to hook into three events:

- *AskUserQuestion*: Claude needs my input. High priority notification.
- *Stop*: Claude finished the task. Normal priority.
- *Error*: Something broke. High priority.

**** The notification script
:PROPERTIES:
:ID:       9e5552b5-f8b9-4ba9-9e30-95eac0099804
:END:

First, the script that sends notifications. I created
~~/.claude/hooks/notify.sh~:

#+begin_src bash
#!/usr/bin/env bash

# Only notify if we're in an SSH-originated tmux session
if ! tmux show-environment SSH_CONNECTION 2>/dev/null | grep -q SSH_CONNECTION=; then
    exit 0
fi

EVENT_TYPE="${1:-unknown}"
NTFY_URL="https://ntfy.example.com/claude-code"
NTFY_TOKEN="tk_your_token_here"

EVENT_DATA=$(cat)

case "$EVENT_TYPE" in
    question)
        TITLE="ğŸ¤” Claude needs input"
        PRIORITY="high"
        MESSAGE=$(echo "$EVENT_DATA" | jq -r '.tool_input.question // .tool_input.questions[0].question // "Claude has a question for you"' 2>/dev/null)
        ;;
    stop)
        TITLE="âœ… Claude finished"
        PRIORITY="default"
        MESSAGE="Task complete"
        ;;
    error)
        TITLE="âŒ Claude hit an error"
        PRIORITY="high"
        MESSAGE=$(echo "$EVENT_DATA" | jq -r '.error // "Something went wrong"' 2>/dev/null)
        ;;
    *)
        TITLE="Claude Code"
        PRIORITY="default"
        MESSAGE="Event: $EVENT_TYPE"
        ;;
esac

PROJECT=$(basename "$PWD")

curl -s \
    -H "Authorization: Bearer $NTFY_TOKEN" \
    -H "Title: $TITLE" \
    -H "Priority: $PRIORITY" \
    -H "Tags: computer" \
    -d "[$PROJECT] $MESSAGE" \
    "$NTFY_URL" > /dev/null 2>&1
#+end_src

#+begin_src bash
chmod +x ~/.claude/hooks/notify.sh
#+end_src

The ~SSH_CONNECTION~ check at the top is crucial: it prevents notifications from
firing when I'm sitting at the machine. Since I only use tmux when SSHing in
remotely, the tmux environment will only have ~SSH_CONNECTION~ set when I'm
remote. Neat trick.

**** Claude Code settings
:PROPERTIES:
:ID:       0475faa7-8821-4e2e-9d5e-73e4147f0f53
:END:

Then in ~~/.claude/settings.json~:

#+begin_src json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "AskUserQuestion",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/notify.sh question"
          }
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/notify.sh stop"
          }
        ]
      }
    ]
  }
}
#+end_src

This is the global settings file. If your project also has a
~.claude/settings.json~, they'll be merged. No conflicts.

**** ntfy setup
:PROPERTIES:
:ID:       624940c8-dd52-4d47-935f-ec27d07bb61c
:END:

I'm self-hosting ntfy, so I created a topic and an access token:

#+begin_src bash
# Inside your ntfy server/container
ntfy token add --expires=30d your-username
ntfy access your-username claude-code rw
ntfy access everyone claude-code deny
#+end_src

ntfy topics are created on demand, so just subscribing to one creates it. On the
Android ntfy app, I pointed it at my self-hosted instance and subscribed to the
~claude-code~ topic.

You can test the whole thing works with:

#+begin_src bash
echo '{"tool_input":{"question":"Should I refactor this?"}}' | ~/.claude/hooks/notify.sh question
echo '{}' | ~/.claude/hooks/notify.sh stop
echo '{"error":"ModuleNotFoundError: No module named foo"}' | ~/.claude/hooks/notify.sh error
#+end_src

Three notifications, three different priorities. Very satisfying.

**** Alternative notification systems
:PROPERTIES:
:ID:       eca9ace7-8862-489e-a75f-8ca29a2aff7e
:END:

If you don't want to self-host ntfy, here are some options:

- *[[https://ntfy.sh][ntfy.sh]]*: The public instance of ntfy. Free, no setup, just pick a
  random-ish topic name. The downside is that anyone who knows your topic name
  can send you notifications.
- *[[https://pushover.net/][Pushover]]*: $5 one-time purchase per platform. Very reliable, nice API. The
  notification script would be almost identical, just a different curl call.
- *[[https://gotify.net/][Gotify]]*: Self-hosted like ntfy, but uses WebSockets instead of HTTP. Good if
  you're already running it.
- *[[https://core.telegram.org/bots/api][Telegram Bot API]]*: Free, easy to set up. Create a bot with BotFather, get
  your chat ID, and curl the sendMessage endpoint.
- *[[https://poke.dev/][Poke]]*: What Granda uses in his post. Simple webhook-to-push service.

*** Phase 4: Termux setup
:PROPERTIES:
:ID:       547a1b54-2b26-476d-808a-fbd7cbe72c72
:END:

Termux is the terminal emulator on my Android phone. Here's how I set it up.

#+begin_src bash
pkg update && pkg install -y mosh openssh fish
#+end_src

**** SSH into your phone (for easier setup)
:PROPERTIES:
:ID:       c0e46fbd-21e2-4ddd-abd3-12797524b70a
:END:

Configuring all of this on a phone keyboard is painful. I set up sshd on Termux
so I could configure it from my PC.

In ~~/.config/fish/config.fish~:

#+begin_src fish
sshd 2>/dev/null
#+end_src

This starts sshd every time you open Termux. If it's already running, it
silently fails. Termux runs sshd on port 8022 by default.

First, set a password on Termux (you'll need it for the initial key copy):

#+begin_src bash
passwd
#+end_src

Then from your PC, copy your key and test the connection:

#+begin_src bash
ssh-copy-id -p 8022 <phone-ip>
ssh -p 8022 <phone-ip>
#+end_src

Now you can configure Termux comfortably from your PC keyboard.

**** Generating SSH keys on the phone
:PROPERTIES:
:ID:       565711d4-6396-40d8-91d2-068d00a30cf8
:END:

On Termux, generate a key pair:

#+begin_src bash
ssh-keygen -t ed25519 -C "phone"
#+end_src

Then copy it to your home server:

#+begin_src bash
ssh-copy-id <your-user>@<home-server-wireguard-ip>
#+end_src

This gives you passwordless ~phone â†’ home server~. Since we already set up
~home server â†’ work PC~ keys in Phase 1, the full chain is now passwordless.

**** SSH config
:PROPERTIES:
:ID:       94f48942-6357-46ab-b55d-09509038e3ca
:END:

The SSH config is where the magic happens. On Termux:

#+begin_src
Host home
    HostName <home-server-wireguard-ip>
    User <your-user>

Host work
    HostName <work-pc-ip>
    User roger
    ProxyJump home
#+end_src

~ProxyJump~ is the key: ~ssh work~ automatically hops through the home server.
No manual double-SSHing.

**** Fish aliases
:PROPERTIES:
:ID:       b60eaeb9-5e64-4f30-b684-12d6658e6617
:END:

These are the aliases that make everything a one-command operation:

#+begin_src fish
# Connect to work PC, land in tmux with Claude Code ready
alias cc="mosh home -- ssh -t work"

# New tmux window in the claude session
alias cn="mosh home -- ssh -t work 'tmux new-window -t claude -c \$HOME/projects/my-app'"

# List tmux windows
alias cl="ssh work 'tmux list-windows -t claude'"
#+end_src

~cc~ is all I need to type. Mosh handles the phone-to-home-server connection
(surviving WiFi/cellular transitions), SSH handles the home-server-to-work-PC
hop over the LAN, and the fish config on the work PC auto-attaches to tmux.

**** Alternative: Termius
:PROPERTIES:
:ID:       384b6a5c-169c-4b51-8ea0-72bba590b13a
:END:

If you're on iOS (or just prefer a polished app), [[https://termius.com/][Termius]] is what Granda uses.
It supports mosh natively and has a nice UI. The downside is it's a subscription
for the full features. Termux is free and open-source, and gives you a full Linux environment.

Other options: [[https://juicessh.com/][JuiceSSH]] (Android, no mosh), [[https://connectbot.org/][ConnectBot]] (Android, no mosh).
Mosh support is really the killer feature here, so Termux or Termius are the
best choices.

*** Phase 5: The full flow
:PROPERTIES:
:ID:       1e04d03a-27f1-479a-9d55-e3c0f9f74d40
:END:

Here's what my actual workflow looks like:

1. I'm at the beach/coffee shop/couch/wherever ğŸ–ï¸
2. Open Termux, type ~cc~
3. I'm in my tmux session on my work PC
4. Start Claude Code, give it a task: "add pagination to the user dashboard API
   and update the tests"
5. Pocket the phone
6. Phone buzzes: "ğŸ¤” Claude needs input â€” Should I use cursor-based or
   offset-based pagination?"
7. Pull out phone, Termux is still connected (thanks mosh), type "cursor-based,
   use the created_at field"
8. Pocket the phone again
9. Phone buzzes: "âœ… Claude finished â€” Task complete"
10. Review the changes, approve the PR, go back to the beach

The key thing that makes this work is the combination of *mosh* (connection
survives me pocketing the phone) + *tmux* (session survives even if mosh dies) +
*ntfy* (I don't have to keep checking the screen). Without any one of these
three, the experience breaks down.

*** Security considerations
:PROPERTIES:
:ID:       cfa3713d-65ec-454e-a6af-dac93ffe92f9
:END:

A few things to keep in mind:

- *SSH keys only*: No password auth anywhere in the chain. Keys are easier to
  manage and impossible to brute force.
- *WireGuard*: The work PC is only accessible through my local network. No ports
  exposed to the public internet.
- *ntfy token auth*: The notification topic requires authentication. No one else
  can send you fake notifications or read your Claude Code questions.
- *Claude Code in normal mode*: Unlike Granda's setup where he runs permissive
  mode on a disposable VM, my work PC is /not/ disposable. Claude asks before
  running dangerous commands, which pairs nicely with the notification system.
- *tmux SSH check*: Notifications only fire when I'm remote. When I'm at the
  machine, no unnecessary pings.

*** Conclusion
:PROPERTIES:
:ID:       e73262a2-04f8-4c71-8ec0-a313371c7147
:END:

The whole setup took me about an hour to put together. The actual configuration
is pretty minimal: an SSH server, a tmux config, a notification script, and some
fish aliases.

What I love about this setup is that it's *all stuff I already had*. WireGuard
was already running, ntfy was already self-hosted, Termux was already on my
phone. I just wired them together with a few scripts and some Claude Code hooks.

If you have a similar homelab setup, you can probably get this running in 30
minutes. If you're starting from scratch, Granda's [[https://granda.org/en/2026/01/02/claude-code-on-the-go/][cloud VM approach]] is probably
easier. Either way, async coding from your phone is genuinely a game changer.

See you in the next one!
** Use your Claude Max subscription as an API with CLIProxyAPI :programming:claude:llm:selfhosted:emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: use-your-claude-max-subscription-as-an-api-with-cliproxyapi
:EXPORT_DATE: 2026-02-13
:ID:       f8a3c1d2-7e4b-4a91-b6d3-2c8e5f9a1b04
:END:

So here's the thing: I'm paying $100/month for Claude Max. I use it a lot, it's
worth it. But then I wanted to use my subscription with my Emacs packages â€”
specifically [[https://gitlab.com/rogs/forge-llm][forge-llm]] (which I wrote!) for generating PR descriptions in Forge,
and [[https://github.com/douo/magit-gptcommit][magit-gptcommit]] for auto-generating commit messages in Magit. Both packages
use the [[https://elpa.gnu.org/packages/llm.html][llm]] package, which supports OpenAI-compatible endpoints.

The problem? Anthropic blocks OAuth tokens from being used directly with
third-party API clients. You /have/ to pay for API access separately. ğŸ¤”

That felt wrong. I'm already paying for the subscription, why can't I use it
however I want?

Turns out, there's a workaround. The Claude Code CLI /can/ use OAuth tokens.
So if you put a proxy in front of it that speaks the OpenAI API format, you can
use your Max subscription with basically anything that supports OpenAI
endpoints. And that's exactly what [[https://github.com/router-for-me/CLIProxyAPI][CLIProxyAPI]] does.

#+begin_src
Your App (Emacs llm package, scripts, whatever)
         â†“
    HTTP Request (OpenAI format)
         â†“
    CLIProxyAPI
         â†“
    OAuth Token (from your Max subscription)
         â†“
    Anthropic API
         â†“
    Response â†’ OpenAI format â†’ Your App
#+end_src

No extra API costs. Just your existing subscription. Sweet!

*** Why CLIProxyAPI and not something else?
:PROPERTIES:
:ID:       a1b2c3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d
:END:

I actually tried [[https://github.com/atalovesyou/claude-max-api-proxy][claude-max-api-proxy]] first. It worked! But the model list was
outdated (no Opus 4.5, no Sonnet 4.5), it's a Node.js project that wraps the
CLI as a subprocess, and it felt a bit... abandoned.

CLIProxyAPI is a completely different story:

- *Single Go binary*. No Node.js, no Python, no runtime dependencies. Just
  download and run.
- *Actively maintained*. Like, /very/ actively. Frequent releases, big
  community, ecosystem tools everywhere (desktop GUI, web dashboard, AUR
  package, Docker images, the works).
- *Multi-provider*. Not just Claude: it also supports Gemini, OpenAI Codex,
  Qwen, and more. You can even round-robin between multiple OAuth accounts.
- *All the latest models*. It uses the full dated model names (e.g.,
  ~claude-sonnet-4-20250514~), so you're always up to date.

*** What you'll need
:PROPERTIES:
:ID:       b2c3d4e5-6f7a-8b9c-0d1e-2f3a4b5c6d7e
:END:

- An active *Claude Max subscription* ($100/month). Claude Pro works too, but
  with lower rate limits.
- A machine running *Linux* or *macOS*.
- A web browser for the OAuth flow (or use ~--no-browser~ if you're on a
  headless server).

*** Installation
:PROPERTIES:
:ID:       c3d4e5f6-7a8b-9c0d-1e2f-3a4b5c6d7e8f
:END:

**** Linux
:PROPERTIES:
:ID:       d4e5f6a7-0000-0000-0000-000000000001
:END:

There's a community installer that does everything for you: downloads the latest
binary to =~/cliproxyapi/=, generates API keys, creates a systemd service:

#+begin_src bash
curl -fsSL https://raw.githubusercontent.com/brokechubb/cliproxyapi-installer/refs/heads/master/cliproxyapi-installer | bash
#+end_src

**** macOS
:PROPERTIES:
:ID:       d4e5f6a7-0000-0000-0000-000000000002
:END:

Homebrew. Easy:

#+begin_src bash
brew install cliproxyapi
#+end_src

*** Authenticating with Claude
:PROPERTIES:
:ID:       e5f6a7b8-9c0d-1e2f-3a4b-5c6d7e8f9a0b
:END:

Before the proxy can use your subscription, you need to log in:

#+begin_src bash
# Linux
cd ~/cliproxyapi
./cli-proxy-api --claude-login

# macOS (Homebrew)
cliproxyapi --claude-login
#+end_src

This opens your browser for the OAuth flow. Log in with your Claude account,
authorize it, done. The token gets saved to =~/.cli-proxy-api/=.

If you're on a headless machine, add ~--no-browser~ and it'll print the URL for
you to open elsewhere:

#+begin_src bash
./cli-proxy-api --claude-login --no-browser
#+end_src

*** Configuration
:PROPERTIES:
:ID:       f6a7b8c9-0d1e-2f3a-4b5c-6d7e8f9a0b1c
:END:

The installer generates a =config.yaml= with random API keys. These are keys
that /clients/ use to authenticate to your proxy, not Anthropic keys.

Here's what I'm running:

#+begin_src yaml
# Bind to localhost only since I'm using it locally
host: "127.0.0.1"

# Server port
port: 8317

# Authentication directory
auth-dir: "~/.cli-proxy-api"

# No client auth needed for local-only use
api-keys: []

# Keep it quiet
debug: false
#+end_src

The important bit is ~api-keys: []~. Setting it to an empty list disables
client authentication, which means any app on your machine can hit the proxy
without needing a key. This is fine if you're only using it locally.

If you're exposing the proxy to your network (e.g., you want to hit it from
your phone or another machine), *keep the generated API keys* and also set
~host: ""~ so it binds to all interfaces. You don't want random people on your
network burning through your subscription.

*** Starting the service
:PROPERTIES:
:ID:       a7b8c9d0-1e2f-3a4b-5c6d-7e8f9a0b1c2d
:END:

**** Linux (systemd)
:PROPERTIES:
:ID:       b8c9d0e1-2f3a-4b5c-6d7e-8f9a0b1c2d3e
:END:

The installer creates a systemd user service for you:

#+begin_src bash
systemctl --user enable --now cliproxyapi.service
systemctl --user status cliproxyapi.service
#+end_src

Or just run it manually to test first:

#+begin_src bash
cd ~/cliproxyapi
./cli-proxy-api
#+end_src

**** macOS (Homebrew)
:PROPERTIES:
:ID:       c9d0e1f2-3a4b-5c6d-7e8f-9a0b1c2d3e4f
:END:

#+begin_src bash
brew services start cliproxyapi
#+end_src

*** Testing it
:PROPERTIES:
:ID:       d0e1f2a3-4b5c-6d7e-8f9a-0b1c2d3e4f5a
:END:

Let's make sure everything works:

#+begin_src bash
# List available models
curl http://localhost:8317/v1/models

# Chat completion
curl -X POST http://localhost:8317/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{
    "model": "claude-sonnet-4-20250514",
    "messages": [{"role": "user", "content": "Say hello in one sentence."}]
  }'

# Streaming (note the -N flag to disable curl buffering)
curl -N -X POST http://localhost:8317/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{
    "model": "claude-sonnet-4-20250514",
    "messages": [{"role": "user", "content": "Say hello in one sentence."}],
    "stream": true
  }'
#+end_src

If you get a response from Claude, you're golden. ğŸ‰

*** Using it with Emacs
:PROPERTIES:
:ID:       e1f2a3b4-5c6d-7e8f-9a0b-1c2d3e4f5a6b
:END:

This is the fun part. Both forge-llm and magit-gptcommit use the [[https://elpa.gnu.org/packages/llm.html][llm]] package
for their LLM backend. The ~llm~ package has an OpenAI-compatible provider, so
we just need to point it at our proxy.

**** Setting up the llm provider
:PROPERTIES:
:ID:       e1f2a3b4-0000-0000-0000-000000000001
:END:

First, make sure you have the ~llm~ package installed. Then configure an OpenAI
provider that points to CLIProxyAPI:

#+begin_src emacs-lisp
(require 'llm-openai)

(setq my/claude-via-proxy
      (make-llm-openai-compatible
       :key "not-needed"
       :chat-model "claude-sonnet-4-20250514"
       :url "http://localhost:8317/v1"))
#+end_src

That's it. That's the whole LLM setup. Now we can use it everywhere.

**** forge-llm (PR descriptions)
:PROPERTIES:
:ID:       e1f2a3b4-0000-0000-0000-000000000002
:END:

I wrote [[https://gitlab.com/rogs/forge-llm][forge-llm]] to generate PR descriptions in Forge using LLMs. It
analyzes the git diff, picks up your repository's PR template, and generates a
structured description. To use it with CLIProxyAPI:

#+begin_src emacs-lisp
(use-package forge-llm
  :after forge
  :config
  (forge-llm-setup)
  (setq forge-llm-llm-provider my/claude-via-proxy))
#+end_src

Now when you're creating a PR in Forge, you can hit ~SPC m g~ (Doom) or run
~forge-llm-generate-pr-description~ and Claude will write the description based
on your diff. Using your subscription. No API key needed.

**** magit-gptcommit (commit messages)
:PROPERTIES:
:ID:       e1f2a3b4-0000-0000-0000-000000000003
:END:

[[https://github.com/douo/magit-gptcommit][magit-gptcommit]] does the same thing but for commit messages. It looks at your
staged changes and generates a conventional commit message. Setup:

#+begin_src emacs-lisp
(use-package magit-gptcommit
  :after magit
  :config
  (setq magit-gptcommit-llm-provider my/claude-via-proxy)
  (magit-gptcommit-mode 1)
  (magit-gptcommit-status-buffer-setup))
#+end_src

Now in the Magit commit buffer, you can generate a commit message with Claude.
Again, no separate API costs.

**** Any other llm-based package
:PROPERTIES:
:ID:       e1f2a3b4-0000-0000-0000-000000000004
:END:

The beauty of the ~llm~ package is that any Emacs package that uses it can
benefit from this setup. Just pass ~my/claude-via-proxy~ as the provider. Some
other packages that use ~llm~: [[https://github.com/s-kostyaev/ellama][ellama]], [[https://github.com/ahyatt/ekg][ekg]], [[https://github.com/akirak/llm-refactoring][llm-refactoring]]. They'll all
work with your Max subscription through the proxy.

*** Using it with other tools
:PROPERTIES:
:ID:       f1a2b3c4-0000-0000-0000-000000000001
:END:

Since CLIProxyAPI speaks the OpenAI API format, it works with anything that
supports custom OpenAI endpoints. The magic three settings are always the same:

- *Base URL*: ~http://localhost:8317/v1~
- *API key*: ~not-needed~ (or your proxy key if you have auth enabled)
- *Model*: ~claude-sonnet-4-20250514~, ~claude-opus-4-20250514~, etc.

Here's a Python example using the OpenAI SDK:

#+begin_src python
from openai import OpenAI

client = OpenAI(
    base_url="http://localhost:8317/v1",
    api_key="not-needed"
)

response = client.chat.completions.create(
    model="claude-sonnet-4-20250514",
    messages=[{"role": "user", "content": "Hello!"}]
)

print(response.choices[0].message.content)
#+end_src

*** Available models
:PROPERTIES:
:ID:       f2a3b4c5-6d7e-8f9a-0b1c-2d3e4f5a6b7c
:END:

CLIProxyAPI exposes all models available through your subscription. The names
use the full dated format. You can always check the list with:

#+begin_src bash
curl -s http://localhost:8317/v1/models | jq '.data[].id'
#+end_src

At the time of writing, you'll get Claude Opus 4, Sonnet 4, Sonnet 4.5,
Haiku 4.5, and whatever else Anthropic has made available to Max subscribers.

*** How much does this save?
:PROPERTIES:
:ID:       a3b4c5d6-7e8f-9a0b-1c2d-3e4f5a6b7c8d
:END:

If you're already paying for Claude Max, this is basically free API access.
For context:

| Usage                     | API Cost    | With CLIProxyAPI |
|---------------------------+-------------+------------------|
| 1M input tokens/month     | ~$15        | $0 (included)    |
| 500K output tokens/month  | ~$37.50     | $0 (included)    |
| *Monthly Total*           | *~$52.50*   | *$0 extra*       |

And those numbers add up quick when you're generating PR descriptions and
commit messages all day. I was getting to the point where my API costs were
approaching the subscription price, which is silly when you think about it.

*** Conclusion
:PROPERTIES:
:ID:       b4c5d6e7-8f9a-0b1c-2d3e-4f5a6b7c8d9e
:END:

The whole setup took me about 10 minutes. Download binary, authenticate, edit
config, start service, point my Emacs ~llm~ provider at it. That's it.

What I love about CLIProxyAPI is that it's exactly the kind of tool I
appreciate: a single binary, a YAML config, does one thing well, and gets out
of your way. No magic, no framework, no runtime dependencies. And since it's
OpenAI-compatible, it plays nicely with the entire ~llm~ package ecosystem in
Emacs.

The project is at https://github.com/router-for-me/CLIProxyAPI and the
community is very active. If you run into issues, their GitHub issues are
responsive.

See you in the next one!
* Announcements :announcements:
:PROPERTIES:
:ID:       0b36e39a-3389-4809-ae40-64ce37d452a1
:END:
All posts in here will have the category set to /announcements/.
** Removing comments from my blog
:PROPERTIES:
:ID:       9270279f-5911-4d91-a514-6be2a232ebc1
:EXPORT_FILE_NAME: removing-comments-from-my-blog
:EXPORT_DATE: 2023-01-14
:ID:       b7da6c10-ca61-4839-9074-039e11a4475d
:END:

I'm removing comments from my blog.

I've been thinking about this for a while, but I noticed that comments weren't being used and most posts
were not that interesting. Don't get me wrong, I really appreciate your awesome comments, but running
commento takes a lot of resources and I don't really see the full benefit of them.

From now on, if you want to leave a comment ("thank yous", suggestions, etc), you can send me an email.
You'll find my email addess on the [[/contact][Contact]] page.

You have a good and relevant comment, I'll update the relevant post accordingly.

* COMMENT Local Variables
:PROPERTIES:
:ID:       4a361a2c-2acc-4cb9-9683-d047323d091b
:END:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
